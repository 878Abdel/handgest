<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Test ArUco Detection avec JS-ArUco</title>
  <style>
    body {
      font-family: monospace;
      background: #000;
      color: #0f0;
      padding: 20px;
      line-height: 1.6;
    }
    h1 { color: #0ff; }
    .status { margin: 20px 0; padding: 10px; border: 2px solid #0f0; border-radius: 5px; }
    .status.error { border-color: #f00; color: #f00; }
    .status.success { border-color: #0f0; color: #0f0; }
    .status.warning { border-color: #ff0; color: #ff0; }
    video { width: 400px; margin: 10px 0; border: 2px solid #0f0; display: none; }
    canvas { width: 400px; border: 2px solid #0ff; margin: 10px 0; }
    button { padding: 10px 20px; margin: 5px; font-weight: bold; cursor: pointer; }
  </style>
</head>
<body>
  <h1>üéØ TEST D√âTECTION ARUCO</h1>
  
  <div id="log"></div>

  <div class="status" id="libStatus">üì¶ Biblioth√®que: Chargement...</div>
  <div class="status" id="cameraStatus">üì∑ Cam√©ra: Attente...</div>
  <div class="status" id="detectionStatus">üéØ D√©tection: Attente...</div>

  <h2>Flux vid√©o (cach√©):</h2>
  <video id="video" autoplay playsinline muted></video>
  
  <h2>Canvas de d√©tection (draggable pour repositionner):</h2>
  <canvas id="canvas" width="1280" height="720"></canvas>

  <h2>Contr√¥les:</h2>
  <button onclick="startDetection()">‚ñ∂Ô∏è D√©marrer d√©tection</button>
  <button onclick="stopDetection()">‚èπÔ∏è Arr√™ter</button>

  <!-- jsfeat - biblioth√®que de traitement d'image l√©ger -->
  <script src="https://inspirit.github.io/jsfeat-min.js"></script>
  
  <!-- JS-Aruco - d√©tection de marqueurs ArUco -->
  <script src="https://inspirit.github.io/js-aruco/js/aruco.js"></script>

  <script>
    let detectionRunning = false;
    let videoStream = null;
    let arucoDetector = null;

    function log(msg, type = 'normal') {
      const logDiv = document.getElementById('log');
      const line = document.createElement('div');
      line.textContent = msg;
      if (type === 'error') line.style.color = '#f00';
      if (type === 'success') line.style.color = '#0f0';
      if (type === 'warning') line.style.color = '#ff0';
      logDiv.appendChild(line);
      console.log(msg);
    }

    function updateStatus(id, text, type = 'normal') {
      const el = document.getElementById(id);
      el.textContent = text;
      el.className = 'status';
      if (type === 'error') el.className += ' error';
      if (type === 'success') el.className += ' success';
      if (type === 'warning') el.className += ' warning';
    }

    // Initialisation au chargement
    window.addEventListener('load', () => {
      log('üöÄ Page charg√©e');
      
      // V√©rifier si jsaruco est disponible
      setTimeout(() => {
        if (typeof aruco !== 'undefined' && typeof aruco.detectMarkers === 'function') {
          log('‚úÖ jsaruco charg√© avec succ√®s', 'success');
          updateStatus('libStatus', '‚úÖ jsaruco: Disponible', 'success');
          
          // Cr√©er le d√©tecteur ArUco
          try {
            arucoDetector = new aruco.Detector();
            log('‚úÖ D√©tecteur ArUco cr√©√©', 'success');
            updateStatus('libStatus', '‚úÖ jsaruco: Pr√™t', 'success');
          } catch (e) {
            log('‚ùå Erreur cr√©ation d√©tecteur: ' + e.message, 'error');
            updateStatus('libStatus', '‚ùå jsaruco: Erreur d√©tecteur', 'error');
          }
        } else {
          log('‚ö†Ô∏è jsaruco pas disponible', 'warning');
          updateStatus('libStatus', '‚ö†Ô∏è jsaruco: Pas disponible', 'warning');
        }
      }, 1000);
    });

    async function initCamera() {
      log('\nüì∑ Demande acc√®s cam√©ra...');
      try {
        videoStream = await navigator.mediaDevices.getUserMedia({
          video: {
            width: { ideal: 1280 },
            height: { ideal: 720 },
            facingMode: 'user'
          }
        });
        
        const video = document.getElementById('video');
        video.srcObject = videoStream;
        
        await new Promise(resolve => {
          video.onloadedmetadata = () => {
            video.play();
            log('‚úÖ Cam√©ra d√©marr√©e', 'success');
            updateStatus('cameraStatus', '‚úÖ Cam√©ra: Active', 'success');
            resolve();
          };
        });
      } catch (error) {
        log('‚ùå Erreur cam√©ra: ' + error.message, 'error');
        updateStatus('cameraStatus', '‚ùå Cam√©ra: ' + error.message, 'error');
      }
    }

    function startDetection() {
      if (!arucoDetector) {
        log('‚ùå D√©tecteur pas pr√™t', 'error');
        return;
      }

      if (!videoStream) {
        log('üì∑ Initialisation cam√©ra...', 'warning');
        initCamera().then(() => startDetection());
        return;
      }

      detectionRunning = true;
      log('\n‚ñ∂Ô∏è D√©tection d√©marr√©e', 'success');
      updateStatus('detectionStatus', '‚ñ∂Ô∏è D√©tection: En cours', 'success');
      
      detectFrame();
    }

    function stopDetection() {
      detectionRunning = false;
      log('‚èπÔ∏è D√©tection arr√™t√©e', 'warning');
      updateStatus('detectionStatus', '‚èπÔ∏è D√©tection: Arr√™t√©e', 'warning');
    }

    let detectionCount = 0;
    function detectFrame() {
      if (!detectionRunning) return;

      requestAnimationFrame(detectFrame);

      const video = document.getElementById('video');
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');

      if (video.readyState !== video.HAVE_ENOUGH_DATA) return;

      try {
        // Dessiner la vid√©o sur le canvas
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

        // D√©tecter les marqueurs
        const markers = arucoDetector.detect(canvas);

        detectionCount++;

        if (detectionCount % 30 === 0) { // Log toutes les 30 frames (~0.5s √† 60fps)
          if (markers && markers.length > 0) {
            log(`‚úÖ ${markers.length} marqueur(s) d√©tect√©(s)! ID: ${markers.map(m => m.id).join(', ')}`, 'success');
            updateStatus('detectionStatus', `‚úÖ ${markers.length} marqueur(s) trouv√©(s)!`, 'success');
          } else {
            log(`‚ùå Aucun marqueur (frame ${detectionCount})`, 'warning');
            updateStatus('detectionStatus', '‚ùå Aucun marqueur d√©tect√©', 'warning');
          }
        }

        // Dessiner les marqueurs d√©tect√©s
        if (markers && markers.length > 0) {
          for (let i = 0; i < markers.length; i++) {
            const marker = markers[i];
            
            // Contour du marqueur
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            for (let j = 0; j < marker.corners.length; j++) {
              const corner = marker.corners[j];
              if (j === 0) ctx.moveTo(corner.x, corner.y);
              else ctx.lineTo(corner.x, corner.y);
            }
            
            // Fermer le contour
            const firstCorner = marker.corners[0];
            ctx.lineTo(firstCorner.x, firstCorner.y);
            ctx.stroke();
            
            // ID du marqueur
            const centerX = marker.corners.reduce((sum, c) => sum + c.x, 0) / marker.corners.length;
            const centerY = marker.corners.reduce((sum, c) => sum + c.y, 0) / marker.corners.length;
            
            ctx.fillStyle = '#ffff00';
            ctx.font = 'bold 24px Arial';
            ctx.fillText('ID:' + marker.id, centerX - 20, centerY - 10);
            
            // Rayon de d√©tection
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 50, 0, Math.PI * 2);
            ctx.stroke();
          }
        }

      } catch (error) {
        log('‚ùå Erreur d√©tection: ' + error.message, 'error');
      }
    }
  </script>
</body>
</html>
