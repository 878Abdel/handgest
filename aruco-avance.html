<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>D√©tection ArUco Pr√©cise</title>
  <style>
    body {
      font-family: monospace;
      background: #000;
      color: #0f0;
      padding: 20px;
      line-height: 1.6;
    }
    h1 { color: #0ff; }
    .status { 
      margin: 20px 0; 
      padding: 10px; 
      border: 2px solid #0f0; 
      border-radius: 5px;
      font-weight: bold;
    }
    .status.error { border-color: #f00; color: #f00; }
    .status.success { border-color: #0f0; color: #0f0; }
    .status.warning { border-color: #ff0; color: #ff0; }
    .info-box {
      background: rgba(0, 255, 0, 0.1);
      border: 1px solid #0f0;
      padding: 15px;
      border-radius: 5px;
      margin: 10px 0;
    }
    video { width: 100%; max-width: 640px; border: 2px solid #0f0; margin: 10px 0; display: none; }
    canvas { width: 100%; max-width: 640px; border: 2px solid #0ff; margin: 10px 0; }
    button { 
      padding: 12px 24px; 
      margin: 10px 5px; 
      font-weight: bold; 
      cursor: pointer;
      background: #0f0;
      color: #000;
      border: none;
      border-radius: 5px;
      font-size: 14px;
    }
    button:hover { background: #0f8; }
    button:disabled { background: #666; cursor: not-allowed; }
    #log { background: #111; border: 1px solid #0f0; padding: 10px; height: 220px; overflow-y: auto; }
    #stats { background: #222; border: 1px solid #888; padding: 10px; margin: 10px 0; }
  </style>
</head>
<body>
  <h1>üéØ D√©tection ArUco Pr√©cise</h1>
  
  <div class="status" id="libStatus">üì¶ Initialisation...</div>
  <div class="status" id="cameraStatus">üì∑ Cam√©ra: Attente...</div>
  <div class="status" id="detectionStatus">üéØ D√©tection: Attente...</div>

  <div class="info-box">
    <strong>D√©tecteur ArUco sp√©cialis√©:</strong><br>
    ‚úì Recherche les 4 carr√©s d'indexation ArUco<br>
    ‚úì Valide la structure sp√©cifique (imbrication)<br>
    ‚úì R√©duit drastiquement les faux positifs
  </div>

  <h2>Flux vid√©o:</h2>
  <video id="video" autoplay playsinline muted></video>
  
  <h2>Analyse:</h2>
  <canvas id="canvas" width="640" height="480"></canvas>

  <div id="stats">
    üîç <strong id="statsText">Analysant...</strong>
  </div>

  <h2>Contr√¥les:</h2>
  <button id="btnStart" onclick="startDetection()">‚ñ∂Ô∏è D√©marrer d√©tection</button>
  <button id="btnStop" onclick="stopDetection()" disabled>‚èπÔ∏è Arr√™ter</button>
  <button id="btnTest" onclick="testMarker()">üß™ Test (carr√© noir)</button>

  <h2>Journal:</h2>
  <div id="log"></div>

  <script>
    let detectionRunning = false;
    let videoStream = null;
    let frameCount = 0;

    function log(msg, type = 'normal') {
      const logDiv = document.getElementById('log');
      const line = document.createElement('div');
      line.textContent = msg;
      if (type === 'error') line.style.color = '#f00';
      if (type === 'success') line.style.color = '#0f0';
      if (type === 'warning') line.style.color = '#ff0';
      logDiv.appendChild(line);
      logDiv.scrollTop = logDiv.scrollHeight;
      console.log(msg);
    }

    function updateStatus(id, text, type = 'normal') {
      const el = document.getElementById(id);
      el.textContent = text;
      el.className = 'status';
      if (type === 'error') el.className += ' error';
      if (type === 'success') el.className += ' success';
      if (type === 'warning') el.className += ' warning';
    }

    // ============ D√âTECTION ARUCO AVANC√âE ============
    // D√©tecte les marqueurs ArUco en cherchant les 4 carr√©s d'indexation
    function detectArucoMarkers(imageData) {
      const data = imageData.data;
      const width = imageData.width;
      const height = imageData.height;
      const candidates = [];

      // Convertir en niveaux de gris
      const gray = new Array(width * height);
      for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        const pixelIndex = i / 4;
        gray[pixelIndex] = 0.299 * r + 0.587 * g + 0.114 * b;
      }

      // Otsu's thresholding automatique pour meilleure binarisation
      const threshold = calculateOtsuThreshold(gray);
      const binary = new Uint8Array(width * height);
      for (let i = 0; i < gray.length; i++) {
        binary[i] = gray[i] > threshold ? 255 : 0;
      }

      // Chercher les contours carr√©s (les 4 coins du marqueur ArUco)
      const minSize = 20;
      const maxSize = 200;
      const step = 10;

      for (let y = minSize; y < height - minSize; y += step) {
        for (let x = minSize; x < width - minSize; x += step) {
          // Chercher un carr√© avec structure noir-blanc-noir
          const marker = findMarkerCorner(binary, width, height, x, y, threshold);
          
          if (marker) {
            // V√©rifier qu'il n'existe pas d√©j√† un marqueur tr√®s proche
            const isDuplicate = candidates.some(m => 
              Math.sqrt((m.x - marker.x) ** 2 + (m.y - marker.y) ** 2) < 50
            );
            
            if (!isDuplicate) {
              candidates.push(marker);
            }
          }
        }
      }

      // √Ä partir des 4 coins d√©tect√©s, construire le marqueur complet
      const markers = buildMarkersFromCorners(candidates, width, height);
      return markers;
    }

    // Calcul du threshold Otsu pour meilleure binarisation
    function calculateOtsuThreshold(gray) {
      const histogram = new Array(256).fill(0);
      
      for (let i = 0; i < gray.length; i++) {
        histogram[Math.floor(gray[i])]++;
      }

      let sum = 0;
      for (let i = 0; i < 256; i++) {
        sum += i * histogram[i];
      }

      let sumB = 0;
      let wB = 0;
      let maxVariance = 0;
      let threshold = 0;

      for (let i = 0; i < 256; i++) {
        wB += histogram[i];
        if (wB === 0) continue;

        const wF = gray.length - wB;
        if (wF === 0) break;

        sumB += i * histogram[i];
        const mB = sumB / wB;
        const mF = (sum - sumB) / wF;

        const variance = wB * wF * (mB - mF) * (mB - mF);

        if (variance > maxVariance) {
          maxVariance = variance;
          threshold = i;
        }
      }

      return threshold;
    }

    // Chercher un coin de marqueur ArUco (structure sp√©cifique)
    function findMarkerCorner(binary, width, height, cx, cy, threshold) {
      const size = 40;
      
      if (cx - size < 0 || cy - size < 0 || cx + size >= width || cy + size >= height) {
        return null;
      }

      // Compter les pixels noirs dans la zone
      let blackCount = 0;
      for (let y = cy - size; y < cy + size; y++) {
        for (let x = cx - size; x < cx + size; x++) {
          if (binary[y * width + x] === 0) blackCount++;
        }
      }

      const blackRatio = blackCount / (size * size * 4);

      // Un coin ArUco doit avoir environ 60-80% de noir
      if (blackRatio > 0.55 && blackRatio < 0.85) {
        // V√©rifier la structure: noir-blanc-noir (imbrication)
        const innerSize = size / 2;
        let innerBlack = 0;

        for (let y = cy - innerSize; y < cy + innerSize; y++) {
          for (let x = cx - innerSize; x < cx + innerSize; x++) {
            if (binary[y * width + x] === 0) innerBlack++;
          }
        }

        const innerRatio = innerBlack / (innerSize * innerSize * 4);

        // L'int√©rieur doit √™tre plus blanc que l'ext√©rieur
        if (innerRatio < blackRatio - 0.2) {
          return {
            x: cx,
            y: cy,
            size: size,
            confidence: Math.min(100, Math.round((blackRatio * 100)))
          };
        }
      }

      return null;
    }

    // Construire les marqueurs complets √† partir des coins d√©tect√©s
    function buildMarkersFromCorners(corners, width, height) {
      if (corners.length < 4) return [];

      // Regrouper les 4 coins du marqueur
      const markers = [];
      
      // Chercher un groupe de 4 coins proches
      for (let i = 0; i < corners.length; i++) {
        const c1 = corners[i];
        const nearbyCorners = [c1];

        for (let j = i + 1; j < corners.length; j++) {
          const c2 = corners[j];
          const dist = Math.sqrt((c1.x - c2.x) ** 2 + (c1.y - c2.y) ** 2);
          
          if (dist < 200 && dist > 50) { // Distance ad√©quate pour les 4 coins
            nearbyCorners.push(c2);
          }
        }

        if (nearbyCorners.length >= 3) {
          // Calculer le centre
          let cx = 0, cy = 0;
          for (let corner of nearbyCorners) {
            cx += corner.x;
            cy += corner.y;
          }
          cx /= nearbyCorners.length;
          cy /= nearbyCorners.length;

          // V√©rifier qu'il n'existe pas d√©j√† un marqueur similaire
          const isDuplicate = markers.some(m => 
            Math.sqrt((m.x - cx) ** 2 + (m.y - cy) ** 2) < 80
          );

          if (!isDuplicate) {
            markers.push({
              x: cx,
              y: cy,
              size: 80,
              id: markers.length,
              confidence: Math.round(nearbyCorners.reduce((sum, c) => sum + c.confidence, 0) / nearbyCorners.length),
              corners: nearbyCorners.length
            });
          }
        }
      }

      return markers;
    }

    // ============ INITIALISATION ============
    window.addEventListener('load', () => {
      log('üöÄ Page charg√©e', 'success');
      updateStatus('libStatus', '‚úÖ D√©tecteur ArUco pr√™t', 'success');
      log('‚úÖ D√©tecteur ArUco avanc√© charg√©');
      log('Cliquez sur "D√©marrer d√©tection"');
    });

    async function initCamera() {
      log('üì∑ Demande acc√®s cam√©ra...');
      try {
        videoStream = await navigator.mediaDevices.getUserMedia({
          video: {
            width: { ideal: 640 },
            height: { ideal: 480 },
            facingMode: 'user'
          }
        });
        
        const video = document.getElementById('video');
        video.srcObject = videoStream;
        
        await new Promise(resolve => {
          video.onloadedmetadata = () => {
            video.play();
            log('‚úÖ Cam√©ra active', 'success');
            updateStatus('cameraStatus', '‚úÖ Cam√©ra: ' + video.videoWidth + 'x' + video.videoHeight, 'success');
            resolve();
          };
        });
      } catch (error) {
        log('‚ùå ' + error.message, 'error');
        updateStatus('cameraStatus', '‚ùå ' + error.message, 'error');
        alert('Erreur cam√©ra: ' + error.message);
      }
    }

    function startDetection() {
      if (!videoStream) {
        initCamera().then(() => startDetection());
        return;
      }

      detectionRunning = true;
      document.getElementById('btnStart').disabled = true;
      document.getElementById('btnStop').disabled = false;
      frameCount = 0;
      
      log('\n‚ñ∂Ô∏è D√©tection D√âMARR√âE', 'success');
      updateStatus('detectionStatus', '‚ñ∂Ô∏è En cours...', 'success');
      
      detectFrame();
    }

    function stopDetection() {
      detectionRunning = false;
      document.getElementById('btnStart').disabled = false;
      document.getElementById('btnStop').disabled = true;
      
      log('‚èπÔ∏è Arr√™t√©e', 'warning');
      updateStatus('detectionStatus', '‚èπÔ∏è Arr√™t√©e', 'warning');
    }

    function detectFrame() {
      if (!detectionRunning) return;

      requestAnimationFrame(detectFrame);

      const video = document.getElementById('video');
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');

      if (video.readyState !== video.HAVE_ENOUGH_DATA) return;

      if (canvas.width !== video.videoWidth || canvas.height !== video.videoHeight) {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
      }

      try {
        ctx.drawImage(video, 0, 0);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

        const markers = detectArucoMarkers(imageData);
        frameCount++;

        // Stats
        const stats = document.getElementById('statsText');
        stats.textContent = `Frame: ${frameCount} | Candidats: ${markers.length}`;

        if (frameCount % 30 === 0) {
          if (markers.length > 0) {
            log(`‚úÖ Frame ${frameCount}: ${markers.length} marqueur(s)!`, 'success');
          } else {
            log(`‚è≥ Frame ${frameCount}: Cherche...`, 'normal');
          }
        }

        // Dessiner
        if (markers.length > 0) {
          ctx.strokeStyle = '#00ff00';
          ctx.lineWidth = 3;
          ctx.fillStyle = '#ffff00';
          ctx.font = 'bold 16px Arial';

          for (let m of markers) {
            ctx.strokeRect(m.x - m.size/2, m.y - m.size/2, m.size, m.size);
            ctx.fillText(`ID:${m.id} (${m.confidence}%)`, m.x - m.size/2, m.y - m.size/2 - 10);

            ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
            ctx.beginPath();
            ctx.arc(m.x, m.y, 8, 0, Math.PI * 2);
            ctx.fill();
          }

          updateStatus('detectionStatus', `‚úÖ ${markers.length} arUco!`, 'success');
        } else {
          updateStatus('detectionStatus', `‚è≥ Recherche...`, 'warning');
        }

      } catch (error) {
        log('‚ùå ' + error.message, 'error');
      }
    }

    function testMarker() {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');

      ctx.fillStyle = '#fff';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Dessiner un marqueur ArUco simplifi√© (4 carr√©s imbriqu√©s)
      const x = canvas.width / 2;
      const y = canvas.height / 2;
      const size = 100;

      ctx.fillStyle = '#000';
      ctx.fillRect(x - size/2, y - size/2, size, size);

      ctx.fillStyle = '#fff';
      ctx.fillRect(x - size/2 + 10, y - size/2 + 10, size - 20, size - 20);

      ctx.fillStyle = '#000';
      ctx.fillRect(x - size/2 + 20, y - size/2 + 20, size - 40, size - 40);

      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const markers = detectArucoMarkers(imageData);

      log(`\nüß™ Test marqueur cr√©√©`, 'normal');
      if (markers.length > 0) {
        log(`‚úÖ D√©tect√©! Confiance: ${markers[0].confidence}%`, 'success');
        updateStatus('detectionStatus', '‚úÖ D√âTECT√â', 'success');
      } else {
        log('‚ùå Non d√©tect√©', 'error');
      }

      ctx.strokeStyle = '#00ff00';
      ctx.lineWidth = 3;
      ctx.strokeRect(x - size/2, y - size/2, size, size);
    }
  </script>
</body>
</html>
